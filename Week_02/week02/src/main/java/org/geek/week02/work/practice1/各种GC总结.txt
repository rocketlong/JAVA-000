各种GC总结：

串行GC：单线程执行，效率不高，当内存比较大时，GC暂停时间较长

并行GC：并行执行，当GC线程在执行的时候，用户线程暂停，把所有的CPU资源全部用在GC处理上，并行GC在年轻代使用标记-复制算法，老年代采用标记-清除-整理算法，
Young GC效率很高，速度很快，Full GC在内存比较大的时候，耗时比较多，但是吞吐量大，是JDK8默认的垃圾收集器

CMS GC：
	优点：每次GC延迟较低，CMS GC主要是用在老年代的垃圾收集器，分为六个阶段，只有初始标记和最终标记需要STW，其余阶段和用户线程一起并发执行。
	缺点：老年代碎片问题，因为不压缩，所以剩余内存不连续，在某些情况下GC会造成不可预测的暂停时间，特别是在堆内存比较大的情况下
	一般用法：ParNew（年轻代）+ CMS（老年代）的处理模式，比较适用于解决垃圾收集长时间卡顿的问题

G1 GC：JDK9版本以后的默认垃圾收集器
	优点：将堆内存划分为多个小块堆（通常2048个）Region的区域，适用于堆内存比较大的情况，比如两个比较重要的参数：
	1）-XX:MaxGCPauseMillis：预期G1每次执行操作的暂停时间，单位是毫秒，默认值是200毫秒，G1就会尽量保证控制在这个范围内
	2）-XX:ConcGCThreads：与Java应用一起执行的GC线程数，默认是CPU核数的1/4，减少这个参数的数值可能会提升并行回收效率，提高系统内部的吞吐量。
	如果这个数值过低，参与回收垃圾线程不足，会导致并行回收机制耗时长
	缺点：某些情况下G1触发Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作，它仅仅使用单线程来完成GC工作，GC暂停可能会达到秒级。
	G1 GC的三种处理：
	1、年轻代模式转移暂停（Evacuation Pause）
	2、并发标记（Concurrent Mark）：与CMS的并发标记类似
	3、混合模式（Evacuation Pause（mixed））：G1将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年代也加入到回收集中。
	混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发的腾出很多小堆块，
	就没有必要启动混合模式因此并发标记和混合转移暂停之间，很可能会存在多次young模式的转移暂停